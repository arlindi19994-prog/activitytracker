const PDFDocument = require('pdfkit');
const ExcelJS = require('exceljs');

async function generatePDF(activities, username) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    const buffers = [];

    doc.on('data', buffers.push.bind(buffers));
    doc.on('end', () => {
      const pdfData = Buffer.concat(buffers);
      resolve(pdfData);
    });
    doc.on('error', reject);

    // Header
    doc.fontSize(20).text('Activity Report', { align: 'center' });
    doc.fontSize(12).text(`Generated by: ${username}`, { align: 'center' });
    doc.fontSize(10).text(`Date: ${new Date().toLocaleDateString()}`, { align: 'center' });
    doc.moveDown(2);

    // Activities
    if (activities.length === 0) {
      doc.fontSize(12).text('No activities found.', { align: 'center' });
    } else {
      activities.forEach((activity, index) => {
        if (doc.y > 700) {
          doc.addPage();
        }

        doc.fontSize(14).fillColor('#333').text(`${index + 1}. ${activity.activity_name}`, { underline: true });
        doc.moveDown(0.5);
        
        doc.fontSize(10).fillColor('#666');
        doc.text(`Description: ${activity.description || 'N/A'}`);
        doc.text(`GXP Scope: ${activity.gxp_scope}`);
        doc.text(`Priority: ${activity.priority}`);
        doc.text(`Risk Level: ${activity.risk_level}`);
        doc.text(`Date: ${activity.activity_date}`);
        doc.text(`Sprint: ${activity.sprint}`);
        doc.text(`Status: ${activity.status}`);
        doc.text(`Created by: ${activity.created_by_name}`);
        
        if (activity.last_edited_at) {
          doc.text(`Last edited: ${new Date(activity.last_edited_at).toLocaleString()}`);
        }
        
        doc.moveDown(1);
      });
    }

    doc.end();
  });
}

async function generateExcel(activities) {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('Activities');

  // Define columns
  worksheet.columns = [
    { header: 'ID', key: 'id', width: 8 },
    { header: 'Activity Name', key: 'activity_name', width: 30 },
    { header: 'Description', key: 'description', width: 40 },
    { header: 'GXP Scope', key: 'gxp_scope', width: 12 },
    { header: 'Priority', key: 'priority', width: 12 },
    { header: 'Risk Level', key: 'risk_level', width: 12 },
    { header: 'Date', key: 'activity_date', width: 15 },
    { header: 'Sprint', key: 'sprint', width: 10 },
    { header: 'Status', key: 'status', width: 15 },
    { header: 'Created By', key: 'created_by_name', width: 20 },
    { header: 'Last Edited', key: 'last_edited_at', width: 20 }
  ];

  // Style header row
  worksheet.getRow(1).font = { bold: true };
  worksheet.getRow(1).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FF4472C4' }
  };
  worksheet.getRow(1).font = { color: { argb: 'FFFFFFFF' }, bold: true };

  // Add data rows
  activities.forEach(activity => {
    const row = worksheet.addRow({
      id: activity.id,
      activity_name: activity.activity_name,
      description: activity.description || '',
      gxp_scope: activity.gxp_scope,
      priority: activity.priority,
      risk_level: activity.risk_level,
      activity_date: activity.activity_date,
      sprint: activity.sprint,
      status: activity.status,
      created_by_name: activity.created_by_name,
      last_edited_at: activity.last_edited_at ? new Date(activity.last_edited_at).toLocaleString() : ''
    });

    // Conditional formatting for priority
    if (activity.priority === 'Critical') {
      if (activity.gxp_scope === 'Yes') {
        // Entire row red
        row.eachCell((cell) => {
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFFF0000' }
          };
          cell.font = { color: { argb: 'FFFFFFFF' } };
        });
      } else {
        // Only priority cell red
        row.getCell('priority').fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFFF0000' }
        };
        row.getCell('priority').font = { color: { argb: 'FFFFFFFF' } };
      }
    }
  });

  // Generate buffer
  const buffer = await workbook.xlsx.writeBuffer();
  return buffer;
}

module.exports = {
  generatePDF,
  generateExcel
};
